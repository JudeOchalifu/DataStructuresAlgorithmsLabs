{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf510
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 10.3 It will allow us to use vectors, arrays, lists, etc. as the underlying data structure for our Queue \
\
10.4 No as Queue is an interface that must be implemented by other classes \
\
10.5 You are in a Queue \
\
10.3 \
You would need two additional stacks.  Pop the elements of the stack until returned value is null and add the results to another stack using push each time.  After, call pop on the newly created stack and for each call, push the result into a new stack ( the copy stack ) and the original stack.  2 extra stacks \
\
10.4\
You would need to call pop until the returned value is null.  Each time you call pop, add the result (push) to a new stack.  After, call pop on the new stack until the returned value is null and add that to a new stack.  After, call pop on the new stack until the returned value is null and add each popped element to the original stack.  2 extra stacks.  original - reversed-not reversed \
\
10.5 You would call poll() and for each call, add the result (offer()) to another queue that would contain the copy and to the queue itself (again).   For each call, you would increment an index value and when it reaches queue's size, would halt the repeated calls.  }